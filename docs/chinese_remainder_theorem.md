# Решение систем линейных сравнений с помощью Китайской теоремы об остатках (КТО)

Этот документ описывает метод решения систем линейных сравнений, который основан на Китайской теореме об остатках. Теорема позволяет найти число `x`, которое удовлетворяет нескольким сравнениям по разным модулям одновременно.

## Теоретическая основа

Задача состоит в том, чтобы найти решение для системы вида:
```
x ≡ a₁ (mod n₁)
x ≡ a₂ (mod n₂)
...
x ≡ aₖ (mod nₖ)
```
где модули `n₁, n₂, ..., nₖ` являются попарно взаимно простыми числами (то есть, НОД(nᵢ, nⱼ) = 1 для любых i ≠ j).

КТО утверждает, что у такой системы всегда есть решение, и это решение единственно по модулю `N = n₁ * n₂ * ... * nₖ`.

### Алгоритм нахождения решения:

1.  **Вычислить произведение всех модулей**:
    `N = n₁ * n₂ * ... * nₖ`

2.  **Для каждого сравнения `i` в системе**:
    a. Найти `Nᵢ = N / nᵢ`. Это произведение всех модулей, кроме `i`-го.
    b. Найти `yᵢ` — мультипликативное обратное для `Nᵢ` по модулю `nᵢ`. То есть, найти такое `yᵢ`, что `(Nᵢ * yᵢ) ≡ 1 (mod nᵢ)`. Это делается с помощью расширенного алгоритма Евклида или, как в данной реализации, через малую теорему Ферма (`mod_inverse`).

3.  **Вычислить окончательное решение**:
    Решение `x` находится как сумма произведений `aᵢ * Nᵢ * yᵢ` по модулю `N`:
    `x ≡ (a₁*N₁*y₁ + a₂*N₂*y₂ + ... + aₖ*Nₖ*yₖ) mod N`

## Реализация

Функция `chinese_remainder_theorem` принимает на вход список `congruences`, где каждый элемент — это пара `(a_i, n_i)`. Она вычисляет и возвращает решение `x` и общий модуль `N`.

### Исходный код

```python
from .long_arithmetic import (LargeNumber, add, subtract, multiply, divide)

def mod_inverse(num, mod):
    # ... (реализация нахождения обратного элемента)
    pass

def chinese_remainder_theorem(congruences):
    base = 10
    # Шаг 1: Вычисляем N = n₁ * n₂ * ... * nₖ
    N = LargeNumber("1", base)
    for _, n_i in congruences:
        N = multiply(N, n_i, base)
    
    total_sum = LargeNumber("0", base)
    
    # Шаги 2 и 3:
    for a_i, n_i in congruences:
        # Находим Nᵢ = N / nᵢ
        N_i, _ = divide(N, n_i, base)
        # Находим yᵢ = (Nᵢ)^-1 mod nᵢ
        y_i = mod_inverse(N_i, n_i)
        
        # Считаем слагаемое aᵢ * Nᵢ * yᵢ
        term = multiply(a_i, N_i, base)
        term = multiply(term, y_i, base)
        
        # Добавляем к общей сумме
        total_sum = add(total_sum, term, base)
        
    # Находим финальное решение по модулю N
    _, solution = divide(total_sum, N, base)
    return solution, N

```
Примечание: Функция `mod_inverse` используется для нахождения мультипликативного обратного и предполагается реализованной. 